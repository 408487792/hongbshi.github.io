<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>browser_proxy</title>
      <link href="/2018/11/09/browser-proxy/"/>
      <url>/2018/11/09/browser-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h1><ol><li><p>什么是正向代理?</p><blockquote><ul><li>简单来说就是代理客户端请求的服务器。例如, 浏览器中设置代理翻墙等。</li></ul></blockquote></li><li><p>正向代理的主要问题?</p><blockquote><ul><li>代理服务器需要知道客户的目标服务器, 例如: 客户一会请求<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>, 一会请求<a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a>, 代理服务器如何获取目标服务器信息。</li></ul></blockquote></li><li><p>正向代理问题的解决方案?</p><blockquote><ul><li>客户端按照某种事先约定的协议通知代理服务器, 例如sock5协议</li><li>代理服务器能够直接从客户端与服务端交互的上层数据包(tcp之上)获取目标服务器信息。例如: 客户端与目标服务器按照http协议通信, 代理服务器可以直接从数据包中解析目标服务器。这种情况不适用与客户端与目标服务器加密通信的情况, 例如https。</li></ul></blockquote></li></ol><h1 id="二-socks5"><a href="#二-socks5" class="headerlink" title="二. socks5"></a>二. socks5</h1><h2 id="2-1-socks5基本流程"><a href="#2-1-socks5基本流程" class="headerlink" title="2.1 socks5基本流程"></a>2.1 socks5基本流程</h2><p>sock5通信的基本流程图如下,<br><img src="https://picturestore.nos-eastchina1.126.net/%E7%BD%91%E7%BB%9C/sock5/socks5%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="image"></p><ol><li>如果不需要认证, 第三步和第四步则不需要。</li></ol><h2 id="2-2-socks5总结"><a href="#2-2-socks5总结" class="headerlink" title="2.2 socks5总结"></a>2.2 socks5总结</h2><ol><li>socks5主要完成目标地址传递的功能<blockquote><ul><li>浏览器与sock5服务器完成tcp握手</li><li>浏览器将目标地址通过socks5协议发送给socks5服务器</li><li>socks5服务器与目标地址完成tcp握手</li><li>浏览器将请求数据发送给socks5服务器, 由其进行转发, 此时可以只做4层tcp代理</li></ul></blockquote></li></ol><h1 id="三-shadowsocks原理"><a href="#三-shadowsocks原理" class="headerlink" title="三. shadowsocks原理"></a>三. shadowsocks原理</h1><p>shadowsocks信息交换的基本结构图如下, ss_cli代表shadowsocks客户端, ss_srv代表shadowsocks服务端,<br><img src="https://picturestore.nos-eastchina1.126.net/%E7%BD%91%E7%BB%9C/shadowsocks/shadowsocks%E4%BB%A3%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image"></p><h2 id="3-1-第一阶段"><a href="#3-1-第一阶段" class="headerlink" title="3.1 第一阶段"></a>3.1 第一阶段</h2><ol><li>客户端与ss_cli建立tcp连接</li><li>客户端与ss_cli协商sock认证参数, ss_cli给与响应, 默认不进行认证</li><li>客户端将目标地址发送给ss_cli, ss_cli给与响应, 默认返回成功</li></ol><h2 id="3-2-第二阶段"><a href="#3-2-第二阶段" class="headerlink" title="3.2 第二阶段"></a>3.2 第二阶段</h2><ol start="4"><li>ss_cli与ss_srv建立tcp连接</li><li>ss_cli将客户端发送的目标地址发送给ss_srv, 此时按照ss_cli与ss_srv协商好的数据包格式, 并不需要使用sock协议, 同时还会发送加密解密需要的随机数</li><li>ss_srv与目标地址建立tcp连接</li></ol><h2 id="3-3-第三阶段"><a href="#3-3-第三阶段" class="headerlink" title="3.3 第三阶段"></a>3.3 第三阶段</h2><ol start="7"><li>客户端向ss_cli发送tcp数据包</li><li>ss_cli将数据包稍作处理, 计算长度, 计算哈希值, 并将这些信息一并发送给ss_srv, 此时的数据包格式是ss_cli与ss_srv约定好的</li><li>ss_srv受到数据后, 解析后发送给目标服务器</li></ol><h2 id="3-4-第四阶段"><a href="#3-4-第四阶段" class="headerlink" title="3.4 第四阶段"></a>3.4 第四阶段</h2><ol start="10"><li>ss_srv收到目标服务器返回的数据后, 将数据按约定好的格式转发给ss_cli</li><li>ss_cli受到数据后, 解析转发给客户</li></ol><h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h2><ol><li>通过sock5协议, ss_cli可以知道客户端的目标服务器地址</li><li>ss_cli与ss_srv可以自行定义协议, 核心是需要将客户端的目标服务器地址以及解密需要的随机变量发送给ss_srv</li><li>ss_cli, ss_srv不需要也无法知道客户端与目标服务器的具体通信信息。</li><li>ss_cli, ss_srv后期是tcp的代理, 不管是https还是http对其而言都是一样的。</li></ol><h2 id="3-6-参考"><a href="#3-6-参考" class="headerlink" title="3.6 参考"></a>3.6 参考</h2><ul><li><a href="https://www.jianshu.com/p/cbea16a096fb" target="_blank" rel="noopener">https://www.jianshu.com/p/cbea16a096fb</a></li></ul><h1 id="四-抓包分析"><a href="#四-抓包分析" class="headerlink" title="四. 抓包分析"></a>四. 抓包分析</h1><ol><li>ss_cli: 127.0.0.1:1080</li><li>ss_srv: 204.48.26.173:21500</li><li>浏览器与ss_cli同属于一个主机, 通信时延低。ss_cli与ss_srv需要通过网络传输, 时延高。数据包分析中可以利用这一点。</li></ol><h2 id="4-1-浏览器与ss-cli通信"><a href="#4-1-浏览器与ss-cli通信" class="headerlink" title="4.1 浏览器与ss_cli通信"></a>4.1 浏览器与ss_cli通信</h2><ol><li><p>tcp握手, 浏览器通过socks5发送目标服务器地址<br><img src="https://picturestore.nos-eastchina1.126.net/%E7%BD%91%E7%BB%9C/shadowsocks/browser-ss_cli-1.png" alt="image"></p></li><li><p>浏览器与ss_cli之间后续的通信, 此处是https协议<br><img src="https://picturestore.nos-eastchina1.126.net/%E7%BD%91%E7%BB%9C/shadowsocks/browser-ss_cli-2.png" alt="image"></p><blockquote><ul><li>时间突变的部分是由于ss_cli需要ss_srv将目标服务器的应答信息发送回来。</li></ul></blockquote></li></ol><h2 id="4-2-ss-cli与ss-srv通信"><a href="#4-2-ss-cli与ss-srv通信" class="headerlink" title="4.2 ss_cli与ss_srv通信"></a>4.2 ss_cli与ss_srv通信</h2><p>二者的通信格式是自行定义的,<br><img src="https://picturestore.nos-eastchina1.126.net/%E7%BD%91%E7%BB%9C/shadowsocks/ss_cli-ss_srv.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
          <category> 代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>结构体传输</title>
      <link href="/2018/11/05/struct-transmission/"/>
      <url>/2018/11/05/struct-transmission/</url>
      
        <content type="html"><![CDATA[<h1 id="一-基础"><a href="#一-基础" class="headerlink" title="一. 基础"></a>一. 基础</h1><ol><li>结构体传输基本上有两种方式,序列化(Json,Xml等)以及直接传输结构体。</li><li>下面考虑32位系统，直接发送结构体进行传输。</li></ol><h1 id="二-结构体"><a href="#二-结构体" class="headerlink" title="二. 结构体"></a>二. 结构体</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> v1;</span><br><span class="line">    <span class="keyword">int</span> v2;</span><br><span class="line">    <span class="keyword">char</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-源码"><a href="#三-源码" class="headerlink" title="三. 源码"></a>三. 源码</h1><h2 id="3-1-发送方"><a href="#3-1-发送方" class="headerlink" title="3.1 发送方"></a>3.1 发送方</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将data写入buf</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">send</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> bufLen, <span class="keyword">const</span> Data *data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bufLen &lt; <span class="keyword">sizeof</span>(*data)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, data, <span class="keyword">sizeof</span>(*data);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main function</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)&#123;</span><br><span class="line">    <span class="keyword">char</span> sendBuf[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">    Data data;</span><br><span class="line">    data.v1 = <span class="string">'a'</span>;</span><br><span class="line">    data.v2 = htonl(<span class="number">2</span>);</span><br><span class="line">    data.v3 = <span class="string">'b'</span>;</span><br><span class="line">    $ans = send(sendBuf, <span class="keyword">sizeof</span>(sendBuf), &amp;data);</span><br><span class="line">    <span class="keyword">if</span>($ans == <span class="literal">false</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//send data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-接收方"><a href="#3-2-接收方" class="headerlink" title="3.2 接收方"></a>3.2 接收方</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//deal data</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">parseData</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> bufLen, Data *data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bufLen &lt; <span class="keyword">sizeof</span>(*data)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    memecpy(buf, data, <span class="keyword">sizeof</span>(*data));</span><br><span class="line">    data.v2 = ntohl(data.v2);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">//read socket recv data</span></span><br><span class="line">    <span class="comment">//deal data</span></span><br><span class="line">    Data data;</span><br><span class="line">    $ans = parseData(buf, <span class="keyword">sizeof</span>(recvBuf), &amp;data);</span><br><span class="line">    <span class="keyword">if</span>($ans == <span class="literal">false</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//Deal data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> v1;</span><br><span class="line">    <span class="keyword">int</span> v2;</span><br><span class="line">    <span class="keyword">char</span> v3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse</span><span class="params">(<span class="keyword">char</span> *buf, Data *data)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(data, buf, <span class="keyword">sizeof</span>(*data));</span><br><span class="line">    data-&gt;v2 = ntohl(data-&gt;v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    Data data;</span><br><span class="line">    data.v1 = <span class="string">'a'</span>;</span><br><span class="line">    data.v2 = htonl(<span class="number">2</span>);</span><br><span class="line">    data.v3 = <span class="string">'b'</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    Data newData;</span><br><span class="line">    parse(buf, &amp;newData);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; newData.v1 &lt;&lt; <span class="string">' '</span> &lt;&lt; newData.v2 &lt;&lt; <span class="string">' '</span> &lt;&lt; newData.v3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出: a, 2, b</span></span><br></pre></td></tr></table></figure><h1 id="四-注意事项"><a href="#四-注意事项" class="headerlink" title="四. 注意事项"></a>四. 注意事项</h1><ol><li>sizeof(data) = 12;</li><li>结构体要考虑对齐,发送方与接收方的对齐方式应该是一致的。</li><li>发送方按照网络字节序存储,接收方得到网络字节序的数据后，解析成本机字节序。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>字节序与位序</title>
      <link href="/2018/11/05/net-byte-order/"/>
      <url>/2018/11/05/net-byte-order/</url>
      
        <content type="html"><![CDATA[<h1 id="一-本机字节序"><a href="#一-本机字节序" class="headerlink" title="一. 本机字节序"></a>一. 本机字节序</h1><ol><li>小端: 低位字节存在低地址。</li><li>大端: 低位字节存在高地址。</li></ol><h1 id="二-本机位序"><a href="#二-本机位序" class="headerlink" title="二. 本机位序"></a>二. 本机位序</h1><p>一般情况下，本机位序与本机的字节序一致。</p><ol><li>小端字节序: 低位bit存在低地址。</li><li>大端字节序: 低位bit存在高地址。</li></ol><h1 id="三-网络序"><a href="#三-网络序" class="headerlink" title="三. 网络序"></a>三. 网络序</h1><ol><li>网络字节序(大端)，先传送高位字节，再传送低位字节。</li><li>在传输一个字节时，先传送低位bit, 再传送高位bit。</li></ol><p>注: 指针指向变量或者数组的起始地址，即指向低地址。</p><h1 id="四-代码示例"><a href="#四-代码示例" class="headerlink" title="四. 代码示例"></a>四. 代码示例</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> byte_order&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b[<span class="number">4</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    byte_order val;</span><br><span class="line">    val.a = <span class="number">0x01020304</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address 0x%x byte: 0x%x\n"</span>, &amp;val.b[<span class="number">0</span>], val.b[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address 0x%x byte: 0x%x\n"</span>, &amp;val.b[<span class="number">1</span>], val.b[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address 0x%x byte: 0x%x\n"</span>, &amp;val.b[<span class="number">2</span>], val.b[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address 0x%x byte: 0x%x\n"</span>, &amp;val.b[<span class="number">3</span>], val.b[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">bit_order</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> a:<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b:<span class="number">4</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> tmp = <span class="number">0x04</span>;</span><br><span class="line">    bit_order *val1 = (bit_order*)&amp;tmp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"low bit %d\n"</span>, val1-&gt;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"high bit %d\n"</span>, val1-&gt;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line">address <span class="number">0x56074a68</span> byte: <span class="number">0x4</span></span><br><span class="line">address <span class="number">0x56074a69</span> byte: <span class="number">0x3</span></span><br><span class="line">address <span class="number">0x56074a6a</span> byte: <span class="number">0x2</span></span><br><span class="line">address <span class="number">0x56074a6b</span> byte: <span class="number">0x1</span></span><br><span class="line">low bit <span class="number">4</span></span><br><span class="line">high bit <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> 数据传输顺序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>水平触发与边沿触发</title>
      <link href="/2018/11/05/LT-ET/"/>
      <url>/2018/11/05/LT-ET/</url>
      
        <content type="html"><![CDATA[<h1 id="一-基础"><a href="#一-基础" class="headerlink" title="一. 基础"></a>一. 基础</h1><h2 id="1-1-水平触发"><a href="#1-1-水平触发" class="headerlink" title="1.1 水平触发"></a>1.1 水平触发</h2><ol><li><p>基本概念</p><blockquote><ul><li>读缓冲区不为空时, 读事件触发。</li><li>写缓冲区不为满时, 写事件触发。</li></ul></blockquote></li><li><p>处理流程</p><blockquote><ul><li>accept新的连接, 监听读事件。</li><li>读事件到达, 处理读事件。</li><li>需要写入数据, 向fd中写数据, 一次无法写完, 开启写事件监听。</li><li>写事件到达, 继续写入数据, 写完后关闭写事件。</li></ul></blockquote></li><li><p>优缺点</p><blockquote><ul><li>不会遗漏事件, 易编程。</li><li>长连接需要写入的数据量大时, 会频繁开启关闭写事件。  </li></ul></blockquote></li></ol><h2 id="1-2-边沿触发"><a href="#1-2-边沿触发" class="headerlink" title="1.2 边沿触发"></a>1.2 边沿触发</h2><ol><li><p>基本概念</p><blockquote><ul><li>读缓冲区状态变化时, 读事件触发, 网卡接受到新数据。</li><li>写缓冲区状态变化时, 写事件触发, 网卡发出了新数据。</li></ul></blockquote></li><li><p>处理流程</p><blockquote><ul><li>accept新的连接, 同时监听读写事件。</li><li>读事件到达, 需要一直读取数据, 直到返回EAGAIN。</li><li>写事件到达, 无数据处理则不处理, 有数据待写入则一直写入，直到写完或者返回EAGAIN。</li></ul></blockquote></li><li><p>优缺点</p><blockquote><ul><li>不需要频繁开启关闭事件, 效率较高。</li><li>读写事件处理不当, 可能导致事件丢失, 编程教复杂。</li></ul></blockquote></li></ol><h2 id="1-3-选择"><a href="#1-3-选择" class="headerlink" title="1.3 选择"></a>1.3 选择</h2><ol><li>概述<blockquote><ul><li>对于读事件而言，总体而言, 采用水平触发方式较好。应用程序在读取数据时，可能会一次无法读取全部数据，边沿触发在下一次可能不会触发。如果能够保证一次读取缓存的全部数据，可以采用边沿触发，效率更高, 但同时编程复杂度也高。</li><li>对于写事件，当客户端服务端采用短连接或者采用长连接但发送的数据量比较少时(例如: Redis), 采用水平触发即可。当客户端与服务端是长连接并且数据写入的量比较大时(例如: nginx), 采用边沿触发, 因为边沿触发效率更高。</li><li>目前，linux不支持读写事件分别设置不同的触发方式，具体采用哪种方式触发，需要根据具体需求。</li></ul></blockquote></li></ol><ol start="2"><li><p>监听套接字事件设置</p><blockquote><ul><li>监听套接字不需要监听写事件，只需要监听读事件。</li><li>监听套接字一般采用水平触发方式。(nginx开启multi_accept时，会把监听套接字所有可读的事件全部读取，此时可以使用边沿触发。但为了保证连接不丢失，nginx仍然采用水平触发)</li></ul></blockquote></li><li><p>通信套接字设置</p><blockquote><ul><li>redis对于与客户端通信使用的套接字默认使用水平触发。</li><li>nginx对于与客户端通信使用的套接字默认采用边沿触发。</li></ul></blockquote></li></ol><h1 id="二-参考"><a href="#二-参考" class="headerlink" title="二. 参考"></a>二. 参考</h1><ul><li><a href="https://blog.csdn.net/dongfuye/article/details/50880251" target="_blank" rel="noopener">https://blog.csdn.net/dongfuye/article/details/50880251</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> 水平触发 </tag>
            
            <tag> 边沿触发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>负载均衡</title>
      <link href="/2018/11/01/load_balance/"/>
      <url>/2018/11/01/load_balance/</url>
      
        <content type="html"><![CDATA[<h1 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一. 基础知识"></a>一. 基础知识</h1><h2 id="1-1-基础"><a href="#1-1-基础" class="headerlink" title="1.1 基础"></a>1.1 基础</h2><ol><li>什么是负载均衡?<blockquote><p>当单机提供的并发量不能满足需求时，我们需要多台服务器同时服务。当客户请求到达时，如何为客户选择最合适的服务器?这个问题就是负载均衡问题。</p></blockquote></li><li>负载均衡主要需要解决的问题是哪些?<blockquote><ul><li>从客户端的角度上看，客户需要最快速的得到服务器的相应，负载均衡时需要找出能最快相应客户需求的服务器进行服务。</li><li>从服务端来看如何使得每台服务器都能达到较高的利用率，最大限制的为用户提供快速、可靠的服务是服务端需要考虑的主要问题。</li></ul></blockquote></li></ol><h2 id="1-2-负载均衡分类"><a href="#1-2-负载均衡分类" class="headerlink" title="1.2 负载均衡分类"></a>1.2 负载均衡分类</h2><ol><li><p>硬件</p><blockquote><ul><li>F5</li></ul></blockquote></li><li><p>软件</p><blockquote><ul><li>dns负载均衡</li><li>LVS负载均衡(4层)</li><li>nginx, haproxy(7层)</li></ul></blockquote></li></ol><h1 id="二-F5负载均衡"><a href="#二-F5负载均衡" class="headerlink" title="二. F5负载均衡"></a>二. F5负载均衡</h1><ol><li>F5是一家美国的公司，该公司生产一些硬件设备可以作为负载均衡器使用(例如:big-ip), 本文后续部分所说的F5是指其负载均衡器产品。</li><li>不同的产品实现的功能不一致，具体情况需要根据产品说明书。</li><li>F5可以在4-7层内做负载均衡，用户可以根据需求进行配置。</li><li>由于F5可以做7层负载均衡，故而可以实现会话管理，http处理等。</li></ol><h2 id="2-1-数据转发模式"><a href="#2-1-数据转发模式" class="headerlink" title="2.1 数据转发模式"></a>2.1 数据转发模式</h2><ol><li>standard类型, 这种模式下，客户端与F5服务器建立连接，F5服务器与真实服务器建立连接，F5服务器将客户需求转发给真实服务器，并将真实服务器的相应转发给客户端，此时F5可以查看请求和相应的所有信息。</li><li>四层转发模式(performance L4), 这种模式下，F5只处理4层以下的数据。客户端将数据发送给F5, F5仅将数据转发给真实服务器，包括TCP的握手数据包以及挥手数据包，真实服务器需要先将数据发送给F5服务器，F5将其转发给客户端。</li><li>路由模式, 这种模式与LVS的DR模式类似。</li><li>…</li></ol><h2 id="2-2-负载均衡算法"><a href="#2-2-负载均衡算法" class="headerlink" title="2.2 负载均衡算法"></a>2.2 负载均衡算法</h2><ol><li>轮询，加权轮询。</li><li>源地址哈希</li><li>…</li></ol><h2 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h2><p>F5的优势在于功能强大，并发量高，能满足客户的大多数需求，但其成本较高，一般大型国企可能会使用。</p><h2 id="2-4-参考"><a href="#2-4-参考" class="headerlink" title="2.4 参考"></a>2.4 参考</h2><ul><li><a href="https://f5.com/zh" target="_blank" rel="noopener">https://f5.com/zh</a></li><li><a href="https://www.jianshu.com/p/2b55aa4c21e2" target="_blank" rel="noopener">https://www.jianshu.com/p/2b55aa4c21e2</a></li><li><a href="https://wenku.baidu.com/view/450b8643cc7931b765ce15c1.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/450b8643cc7931b765ce15c1.html</a></li></ul><h1 id="三-dns负载均衡"><a href="#三-dns负载均衡" class="headerlink" title="三. dns负载均衡"></a>三. dns负载均衡</h1><ol><li>dns负载均衡由dns服务提供厂商提供。</li><li>最初的dns负载均衡提供简单轮询，不能根据客户端或者服务端状态进行选择。</li><li>目前，有些dns服务厂商可以提供智能dns服务，用户可以设置负载均衡方案，例如：根据客户端ip地址，选择就近的服务器。</li><li>对于目前大多数的公司而言，为了更好的服务用户，通常会使用dns负载均衡，将用户按照就近原则，分配到某个集群服务器上。之后，集群内再采用其他的负载均衡方案。</li></ol><h1 id="四-Linux-Virtual-Server-LVS"><a href="#四-Linux-Virtual-Server-LVS" class="headerlink" title="四. Linux Virtual Server(LVS)"></a>四. Linux Virtual Server(LVS)</h1><ol><li>LVS通过修改数据包Ip地址，Mac地址实现负载均衡。</li><li>LVS由ipvs(内核中), ipvsadm(用户态)组成。LVS需要理解tcp，ip头部。</li><li>当tcp握手信号，SYN数据包达到时，ipvs选择一个后端服务器，将数据包进行转发。在此之后，所有包含相同的ip，tcp头部的数据包都会被转发到之前选择的服务器上。很明显，ipvs无法感知数据包内容。</li></ol><h2 id="4-1-分类"><a href="#4-1-分类" class="headerlink" title="4.1 分类"></a>4.1 分类</h2><ul><li>LVS-NAT</li><li>LVS-DR</li><li>LVS-TUN</li></ul><h2 id="4-2-基本原理"><a href="#4-2-基本原理" class="headerlink" title="4.2 基本原理"></a>4.2 基本原理</h2><h3 id="4-2-1-LVS-DR"><a href="#4-2-1-LVS-DR" class="headerlink" title="4.2.1 LVS-DR"></a>4.2.1 LVS-DR</h3><p>LVS-DR模式的基本原理如下图所示:<br><img src="https://picturestore.nos-eastchina1.126.net/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/lvs-dr.png" alt="image"></p><h3 id="4-2-2-LVS-NAT"><a href="#4-2-2-LVS-NAT" class="headerlink" title="4.2.2 LVS-NAT"></a>4.2.2 LVS-NAT</h3><p>LVS-NAT模式的基本原理如下图所示:<br><img src="https://picturestore.nos-eastchina1.126.net/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/lvs-nat.png" alt="image"></p><h2 id="4-3-负载均衡算法"><a href="#4-3-负载均衡算法" class="headerlink" title="4.3 负载均衡算法"></a>4.3 负载均衡算法</h2><h3 id="4-3-1-静态算法"><a href="#4-3-1-静态算法" class="headerlink" title="4.3.1 静态算法"></a>4.3.1 静态算法</h3><ol><li>轮询(Round Robin, RR)</li><li>加权轮询(Weight Round Robin, WRR)</li><li>源地址Hash(Source Hash, SH)</li><li>目的地址Hash(Destination Hash, DH), 可以设置多个VIP</li></ol><h3 id="4-3-2-动态算法"><a href="#4-3-2-动态算法" class="headerlink" title="4.3.2 动态算法"></a>4.3.2 动态算法</h3><ol><li>最少连接(Least Connections, LC)，找出当前连接数最小的服务器</li><li>加权最少连接(Weighted Least Connections, WLC)</li><li>最短期望延迟(Shortest Expected Delay Scheduling, SED) 基于WLC。例如: 现有A, B, C三台服务器，权重分别为100,200,300，当前的连接数分别为1,2,3,下一个连接到达时，通过计算期望时延选择服务器(1+1)/100, (2+1)/200, (3+1)/300, 故而选择C服务器。</li><li>永不排队(Never Queue Scheduling, NQ)， 改进的sed, 如果某台服务器连接数为0，直接连接过去，不在进行sed计算。</li><li>基于局部性的最少连接(locality-Based Least Connections, LBLC)，根据目标ip, 找出目标ip最近使用的服务器，如果服务器存在并且负载没有大于一个阈值，则将新的连接分配到这个服务器上，否则按照最少连接找出一个服务器处理该请求。</li><li>带复制的基于局部性最少连接(Locality-Based Least Connections with Replication, LBLCR)，根据目标ip，维护一个服务器组，每次从组中挑选服务器，如果服务器不可以处理，则从所有服务器中按照最少连接挑选出一台服务器，并将其加入到目标ip的处理组服务器中。</li></ol><h2 id="4-3-参考"><a href="#4-3-参考" class="headerlink" title="4.3 参考"></a>4.3 参考</h2><ul><li><a href="https://liangshuang.name/2017/11/19/lvs/" target="_blank" rel="noopener">https://liangshuang.name/2017/11/19/lvs/</a></li></ul><h1 id="五-Nginx-Load-Balance"><a href="#五-Nginx-Load-Balance" class="headerlink" title="五. Nginx Load Balance"></a>五. Nginx Load Balance</h1><ol><li>nginx负载均衡工作在7层，它会与client、upstream分别建立tcp连接，nginx需要维护这两个连接的状态。</li><li>nginx的stream模块可以用于4层负载均衡，但一般很少使用。</li></ol><h2 id="5-1-基本原理"><a href="#5-1-基本原理" class="headerlink" title="5.1 基本原理"></a>5.1 基本原理</h2><p>nginx做7层负载均衡的基本原理如下图所示:<br><img src="https://picturestore.nos-eastchina1.126.net/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="image"></p><h2 id="5-2-负载均衡算法"><a href="#5-2-负载均衡算法" class="headerlink" title="5.2 负载均衡算法"></a>5.2 负载均衡算法</h2><ol><li>轮询(默认)</li><li>加权轮询</li><li>源ip哈希</li><li>响应时间</li><li>url 哈希</li></ol>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 负载均衡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 分布式技术 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nginx内存管理</title>
      <link href="/2018/10/31/nginx_memory_manage/"/>
      <url>/2018/10/31/nginx_memory_manage/</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h1><ol><li>应用程序的内存可以简单分为堆内存，栈内存。对于栈内存而言，在函数编译时，编译器会插入移动栈当前指针位置的代码，实现栈空间的自管理。而对于堆内存，通常需要程序员进行管理。我们通常说的内存管理亦是只堆空间内存管理。</li></ol><ol start="2"><li>对于内存，我们的使用可以简化为3步，申请内存、使用内存、释放内存。申请内存，使用内存通常需要程序员显示操作，释放内存却并不一定需要程序员显示操作，目前很多的高级语言提供了垃圾回收机制，可以自行选择时机释放内存，例如: Go、Java已经实现垃圾回收, C语言目前尚未实现垃圾回收，C++中可以通过智能指针达到垃圾回收的目的。</li></ol><ol start="3"><li>除了语言层面的内存管理外，有时我们需要在程序中自行管理内存，总体而言，对于内存管理，我认为主要是解决以下问题:</li></ol><ul><li>用户申请内存时，如何快速查找到满足用户需求的内存块？ </li><li>用户释放内存时，如何避免内存碎片化？</li></ul><blockquote><p>无论是语言层面实现的内存管理还是应用程序自行实现的内存管理，大都将内存按照大小分为几种，每种采用不同的管理模式。常见的分类是按照2的整数次幂分，将不同种类的内存通过链表链接，查询时，从相应大小的链表中寻找，如果找不到，则可以考虑从更大块内存中，拿取一块，将其分为多个小点的内存。当然，对于特别大的内存，语言层面的内存管理可以直接调用内存管理相关的系统调用，应用层面的内存管理则可以直接使用语言层面的内存管理。</p></blockquote><ol start="4"><li>nginx内存管理整体可以分为2个部分，</li></ol><ul><li>第一部分是常规的内存池，用于进程平时所需的内存管理；</li><li>第二部分是共享内存的管理。总体而言，共享内存教内存池要复杂的多。</li></ul><h1 id="二-nginx内存池管理"><a href="#二-nginx内存池管理" class="headerlink" title="二. nginx内存池管理"></a>二. nginx内存池管理</h1><h2 id="2-1-说明"><a href="#2-1-说明" class="headerlink" title="2.1 说明"></a>2.1 说明</h2><ol><li>本部分使用的nginx版本为1.15.3</li><li>具体源码参见src/core/ngx_palloc.c文件</li></ol><h2 id="2-2-nginx实现"><a href="#2-2-nginx实现" class="headerlink" title="2.2 nginx实现"></a>2.2 nginx实现</h2><h3 id="2-2-1-使用流程"><a href="#2-2-1-使用流程" class="headerlink" title="2.2.1 使用流程"></a>2.2.1 使用流程</h3><p>nginx内存池的使用较为简单,可以分为3步，</p><ul><li><p>调用ngx_create_pool函数获取ngx_pool_t指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size代表ngx_pool_t一块的大小</span></span><br><span class="line"><span class="keyword">ngx_pool_t</span>* ngx_create_pool(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br></pre></td></tr></table></figure></li><li><p>调用ngx_palloc申请内存使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从pool中申请size大小的内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ngx_palloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure></li><li><p>释放内存(可以释放大块内存或者释放整个内存池)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放从pool中申请的大块内存</span></span><br><span class="line"><span class="keyword">ngx_int_t</span> ngx_pfree(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">void</span> *p)</span><br><span class="line"><span class="comment">//释放整个内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-2-具体实现"><a href="#2-2-2-具体实现" class="headerlink" title="2.2.2 具体实现"></a>2.2.2 具体实现</h3><ol><li>如下图所示，nginx将内存分为2种，一种是小内存，一种是大内存，当申请的空间大于pool-&gt;max时，我们认为是大内存空间，否则是小内存空间。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建内存池的参数size减去头部管理结构ngx_pool_t的大小</span></span><br><span class="line">pool-&gt;max = size - <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://picturestore.nos-eastchina1.126.net/nginx/%E5%86%85%E5%AD%98%E6%B1%A0.png" alt="image"></p><ol start="2"><li>对于小块内存空间, nginx首先查看当前内存块待分配的空间中，是否能够满足用户需求，如果可以，则直接将这部分内存返回。如果不能满足用户需求，则需要重新申请一个内存块，申请的内存块与当前块空间大小相同，将新申请的内存块通过链表链接到上一个内存块，从新的内存块中分配用户所需的内存。</li></ol><blockquote><p>小块内存并不释放，用户申请后直接使用，即使后期不再使用也不需要释放该内存。由于用户有时并不知道自己使用的内存块是大是小，此时也可以调用ngx_pfree函数释放该空间，该函数会从大空间链表中查找内存，找到则释放内存。对于小内存而言，并未做任何处理。</p></blockquote><ol start="3"><li>对于大块内存, nginx会将这些内存放到链表中存储，通过pool-&gt;large进行管理。值得注意的是，用户管理大内存的ngx_pool_large_t结构是从本内存池的小块内存中申请而来，也就意味着无法释放这些内存，nginx则是直接复用ngx_pool_large_t结构体。当用户需要申请大内存空间时，利用c函数库malloc申请空间，然后将其挂载某个ngx_pool_large_t结构体上。nginx在需要一个新的ngx_pool_large_t结构时，会首先pool-&gt;large链表的前3个元素中，查看是否有可用的,如果有则直接使用，否则新建ngx_pool_large_t结构。</li></ol><h1 id="三-nginx共享内存管理"><a href="#三-nginx共享内存管理" class="headerlink" title="三. nginx共享内存管理"></a>三. nginx共享内存管理</h1><h2 id="3-1-说明"><a href="#3-1-说明" class="headerlink" title="3.1 说明"></a>3.1 说明</h2><ol><li>本部分使用的nginx版本是1.15.3</li><li>本部分源码详见src/core/ngx_slab.c, src/core/ngx_shmtx.c</li><li>nginx共享内存内容相对较多，本文仅做简单概述。</li></ol><h2 id="3-2-直接使用共享内存"><a href="#3-2-直接使用共享内存" class="headerlink" title="3.2 直接使用共享内存"></a>3.2 直接使用共享内存</h2><h3 id="3-2-1-基础"><a href="#3-2-1-基础" class="headerlink" title="3.2.1 基础"></a>3.2.1 基础</h3><ol><li>nginx中需要创建互斥锁，用于后面多进程同步使用。除此之外，nginx可能需要一些统计信息，例如设置(stat_stub),对于这些变量，我们并不需要特意管理，只需要开辟共享空间后，直接使用即可。</li><li>设置stat_stub后所需的统计信息，亦是放到共享内存中，我们此处仅以nginx中的互斥锁进行说明。</li></ol><h3 id="3-2-2-nginx互斥锁的实现"><a href="#3-2-2-nginx互斥锁的实现" class="headerlink" title="3.2.2 nginx互斥锁的实现"></a>3.2.2 nginx互斥锁的实现</h3><ol><li>nginx互斥锁，有两种方案，当系统支持原子操作时，采用原子操作，不支持时采用文件锁。本节源码见ngx_event_module_init函数。</li><li>下图为文件锁实现互斥锁的示意图。<br><img src="https://picturestore.nos-eastchina1.126.net/nginx/ngxin%E6%96%87%E4%BB%B6%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81.png" alt="image"></li><li><p>下图为原子操作实现互斥锁的示意图。<br><img src="https://picturestore.nos-eastchina1.126.net/nginx/nginx%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E9%94%81.png" alt="image"></p></li><li><p>问题</p></li></ol><blockquote><ol><li>reload时，新启动的master向老的master发送信号后直接退出，旧的master,重新加载配置(ngx_init_cycle函数), 新创建工作进程, 新的工作进程与旧的工作进程使用的锁是相同的。</li><li>平滑升级时, 旧的master会创建新的master, 新的master会继承旧的master监听的端口(通过环境变量传递监听套接字对应的fd)，新的进程并没有重新绑定监听端口。可能存在新老worker同时监听某个端口的情况，此时操作系统会保证只会有一个进程处理该事件(虽然epoll_wait都会被唤醒)。</li></ol></blockquote><h2 id="3-3-通过slab管理共享内存"><a href="#3-3-通过slab管理共享内存" class="headerlink" title="3.3 通过slab管理共享内存"></a>3.3 通过slab管理共享内存</h2><ol><li>nginx允许各个模块开辟共享空间以供使用,例如ngx_http_limit_conn_module模块。</li><li>nginx共享内存管理的基本思想有:</li></ol><blockquote><ol><li>将内存按照页进行分配，每页的大小相同, 此处设为page_size。</li><li>将内存块按照2的整数次幂进行划分, 最小为8bit, 最大为page_size/2。例如，假设每页大小为4Kb, 则将内存分为8, 16, 32, 64, 128, 256, 512, 1024, 2048共9种，每种对应一个slot, 此时slots数组的大小n即为9。申请小块内存(申请内存大小size &lt;= page_size/2)时，直接给用户这9种中的一种，例如，需要30bit时，找大小为32的内存块提供给用户。</li><li>每个页只会划分一种类型的内存块。例如，某次申请内存时，现有内存无法满足要求，此时会使用一个新的页，则这个新页此后只会分配这种大小的内存。</li><li>通过双向链表将所有空闲的页连接。图中ngx_slab_pool_t中的free变量即使用来链接空闲页的。</li><li>通过slots数组将所有小块内存所使用的页链接起来。</li><li>对于大于等于页面大小的空间请求，计算所需页数，找到连续的空闲页，将空闲页的首页地址返回给客户使用，通过每页的管理结构ngx_slab_page_t进行标识。</li><li>所有页面只会有3中状态，空闲、未满、已满。空闲，未满都是通过双向链表进行整合，已满页面则不存在与任何页面，当空间被释放时，会将其加入到某个链表。</li></ol></blockquote><ol start="3"><li>nginx共享内存的基本结构图如下:</li></ol><p><img src="https://picturestore.nos-eastchina1.126.net/nginx/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image"></p><ul><li>在上图中，除了最右侧的ngx_slab_pool_t接口开始的一段内存位于共享内存区外，其他内存都不是共享内存。</li><li>共享内存最终是从page中分配而来。</li></ul>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
